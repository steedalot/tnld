#!/usr/bin/env python3
"""
tnl - Tunnel Client for IT.Box
Simple client-side tool to manage SSH reverse tunnels to gateway server.
"""

import os
import sys
import subprocess
import argparse
import yaml
import json
import re
import shutil
from pathlib import Path
from datetime import datetime, timezone

# ============================================================================
# CONSTANTS
# ============================================================================

VERSION = "1.2.2"
TUNNELUSER = "tunneluser"
TUNNELUSER_HOME = "/home/tunneluser"
SSH_KEY_PATH = f"{TUNNELUSER_HOME}/.ssh/tunnel_key"
SYSTEMD_SERVICE_ADMIN = "/etc/systemd/system/tnl-admin.service"
TNL_CONFIG_DIR = "/etc/tnl"
TNL_CONFIG_FILE = "/etc/tnl/config.yml"

# ============================================================================
# EXCEPTIONS
# ============================================================================

class TnlError(Exception):
    """Base exception for tnl errors."""
    pass

# ============================================================================
# UTILITIES
# ============================================================================

def check_root():
    """Ensure script is run as root."""
    if os.geteuid() != 0:
        print("âŒ Error: This command must be run as root")
        print("   Run: sudo tnl ...")
        sys.exit(1)

def run_command(cmd, check=True, capture_output=False):
    """Run shell command."""
    result = subprocess.run(
        cmd,
        shell=isinstance(cmd, str),
        check=check,
        capture_output=capture_output,
        text=True
    )
    return result

# ============================================================================
# CONFIG MANAGEMENT
# ============================================================================

def load_config():
    """Load config from /etc/tnl/config.yml."""
    config_path = Path(TNL_CONFIG_FILE)
    if not config_path.exists():
        raise TnlError(f"Config file not found: {TNL_CONFIG_FILE}\n   Run 'sudo tnl setup' first")

    with open(config_path, 'r') as f:
        return yaml.safe_load(f)

def save_config(config):
    """Save config to /etc/tnl/config.yml."""
    config_dir = Path(TNL_CONFIG_DIR)
    config_dir.mkdir(mode=0o755, parents=True, exist_ok=True)

    with open(TNL_CONFIG_FILE, 'w') as f:
        yaml.dump(config, f, default_flow_style=False, sort_keys=False)

    os.chmod(TNL_CONFIG_FILE, 0o644)

def init_config(gateway_ip, admin_port, ssh_port):
    """Initialize config file during setup."""
    config = {
        'gateway': {
            'ip': gateway_ip,
            'admin_port': admin_port,
            'ssh_port': ssh_port
        },
        'tunnels': {}
    }
    save_config(config)
    return config

# ============================================================================
# VALIDATION
# ============================================================================

def validate_service_name(service):
    """Validate service name (lowercase, numbers, hyphens only)."""
    if not re.match(r'^[a-z0-9-]+$', service):
        raise TnlError(f"Invalid service name '{service}'\n   Must contain only lowercase letters, numbers, and hyphens")

def validate_port(port):
    """Validate port number (1-65535)."""
    if not (1 <= port <= 65535):
        raise TnlError(f"Invalid port {port}\n   Must be between 1 and 65535")

# ============================================================================
# SSH COMMUNICATION
# ============================================================================

def ssh_request(service, local_port, gateway):
    """Request tunnel from gateway via SSH."""
    key_path = Path(SSH_KEY_PATH)

    result = run_command(
        [
            "sudo", "-u", TUNNELUSER,
            "ssh",
            "-i", str(key_path),
            "-o", "StrictHostKeyChecking=no",
            "-o", "ConnectTimeout=10",
            "-p", str(gateway['ssh_port']),
            f"tunneluser@{gateway['ip']}",
            "request", service, str(local_port)
        ],
        check=False,
        capture_output=True
    )

    if result.returncode != 0:
        raise TnlError(f"Gateway request failed:\n   {result.stderr.strip()}")

    return result

def ssh_release(service, gateway):
    """Release tunnel on gateway via SSH."""
    key_path = Path(SSH_KEY_PATH)

    result = run_command(
        [
            "sudo", "-u", TUNNELUSER,
            "ssh",
            "-i", str(key_path),
            "-o", "StrictHostKeyChecking=no",
            "-o", "ConnectTimeout=10",
            "-p", str(gateway['ssh_port']),
            f"tunneluser@{gateway['ip']}",
            "release", service
        ],
        check=False,
        capture_output=True
    )

    # Best effort - log but don't fail
    if result.returncode != 0:
        print(f"   âš  Gateway release warning: {result.stderr.strip()}")

# ============================================================================
# SYSTEMD SERVICE MANAGEMENT
# ============================================================================

def create_service_tunnel(service, local_port, server_port, gateway):
    """Create systemd service for service tunnel."""
    service_name = f"tnl-{service}.service"
    service_path = f"/etc/systemd/system/{service_name}"

    service_content = f"""[Unit]
Description=tnl Service Tunnel: {service} (Local:{local_port} â†’ Gateway:{server_port})
After=network-online.target tnl-admin.service
Wants=network-online.target
Requires=tnl-admin.service

[Service]
Type=simple
User={TUNNELUSER}
Restart=always
RestartSec=10
ExecStart=/usr/bin/autossh -M 0 -N -o "ServerAliveInterval=30" -o "ServerAliveCountMax=3" -o "ExitOnForwardFailure=yes" -o "StrictHostKeyChecking=no" -i {SSH_KEY_PATH} -R {server_port}:localhost:{local_port} -p {gateway['ssh_port']} tunneluser@{gateway['ip']}

[Install]
WantedBy=multi-user.target
"""

    with open(service_path, 'w') as f:
        f.write(service_content)

    os.chmod(service_path, 0o644)

    # Reload and enable
    run_command(["systemctl", "daemon-reload"])
    run_command(["systemctl", "enable", service_name])
    run_command(["systemctl", "start", service_name])

def remove_service_tunnel(service):
    """Remove systemd service for service tunnel."""
    service_name = f"tnl-{service}.service"
    service_path = f"/etc/systemd/system/{service_name}"

    # Stop and disable
    run_command(["systemctl", "stop", service_name], check=False)
    run_command(["systemctl", "disable", service_name], check=False)

    # Remove file
    if Path(service_path).exists():
        os.remove(service_path)

    run_command(["systemctl", "daemon-reload"])

def get_service_status(service):
    """Get systemd service status."""
    service_name = f"tnl-{service}.service"

    result = run_command(
        ["systemctl", "is-active", service_name],
        check=False,
        capture_output=True
    )

    return result.stdout.strip()

# ============================================================================
# UPDATE MECHANISM
# ============================================================================

def detect_installed_version():
    """Detect currently installed version of tnl."""
    installed_path = Path("/usr/local/bin/tnl")

    if not installed_path.exists():
        return None

    try:
        result = subprocess.run(
            [str(installed_path), "version"],
            capture_output=True,
            text=True,
            timeout=5
        )

        # Parse "tnl v1.1.0"
        match = re.search(r'v?(\d+\.\d+\.\d+)', result.stdout)
        if match:
            return match.group(1)
    except Exception:
        pass

    # Fallback: check config for version hint
    try:
        if Path(TNL_CONFIG_FILE).exists():
            config = load_config()
            if '_meta' in config and 'schema_version' in config['_meta']:
                return config['_meta']['schema_version']
    except Exception:
        pass

    return "1.2.1"  # Default to last stable version

def run_config_migrations(config, from_version, to_version):
    """Run config migrations from one version to another.

    Note: Only supports migrations from last stable (1.2.1) to current.
    """
    # Config migrations (none needed for 1.2.1â†’1.2.2)
    migrations = {}

    # Supported version sequence (only last stable â†’ current)
    version_sequence = ["1.2.1", "1.2.2"]

    try:
        from_idx = version_sequence.index(from_version)
        to_idx = version_sequence.index(to_version)
    except ValueError:
        # Unknown version, skip migrations
        print(f"   âš  Unknown version in migration: {from_version} â†’ {to_version}")
        return 0

    migrations_run = 0

    for i in range(from_idx, to_idx):
        current_v = version_sequence[i]
        next_v = version_sequence[i + 1]
        migration_key = f"{current_v}_to_{next_v}"

        if migration_key in migrations:
            print(f"   Running migration: {migration_key}")
            migrations[migration_key](config)
            migrations_run += 1

    # Update config schema version
    config['_meta'] = config.get('_meta', {})
    config['_meta']['schema_version'] = to_version

    return migrations_run

# ============================================================================
# COMMANDS
# ============================================================================

def cmd_install(args):
    """Install tnl client on box."""
    print("ğŸ”§ tnl Client Installation\n")

    check_root()

    # 1. Create tunneluser
    print("1. Creating tunneluser...")
    result = run_command(["id", "tunneluser"], check=False, capture_output=True)

    if result.returncode == 0:
        print("   âœ“ User 'tunneluser' already exists")
        # Ensure home directory exists (might be missing)
        home_dir = Path(TUNNELUSER_HOME)
        if not home_dir.exists():
            print("   Creating home directory...")
            home_dir.mkdir(mode=0o755, parents=True)
            import pwd
            tunneluser_uid = pwd.getpwnam(TUNNELUSER).pw_uid
            tunneluser_gid = pwd.getpwnam(TUNNELUSER).pw_gid
            os.chown(home_dir, tunneluser_uid, tunneluser_gid)
    else:
        # Create user
        run_command([
            "useradd", "-r", "-m",
            "-d", TUNNELUSER_HOME,
            "-s", "/bin/bash",
            TUNNELUSER
        ])
        print("   âœ“ User 'tunneluser' created")

    # 2. Create SSH directory and key
    print("\n2. Generating SSH key...")
    ssh_dir = Path(TUNNELUSER_HOME) / ".ssh"
    ssh_dir.mkdir(mode=0o700, parents=True, exist_ok=True)

    key_path = Path(SSH_KEY_PATH)

    if key_path.exists():
        print("   âœ“ SSH key already exists")
    else:
        # Generate ed25519 key
        run_command([
            "ssh-keygen",
            "-t", "ed25519",
            "-f", str(key_path),
            "-N", "",  # No passphrase
            "-C", f"tunneluser@{os.uname().nodename}"
        ])
        print("   âœ“ SSH key generated")

    # Set ownership
    import pwd
    tunneluser_uid = pwd.getpwnam(TUNNELUSER).pw_uid
    tunneluser_gid = pwd.getpwnam(TUNNELUSER).pw_gid

    os.chown(ssh_dir, tunneluser_uid, tunneluser_gid)
    os.chown(key_path, tunneluser_uid, tunneluser_gid)
    os.chown(str(key_path) + ".pub", tunneluser_uid, tunneluser_gid)

    # 3. Install autossh
    print("\n3. Installing autossh...")
    result = run_command(
        ["which", "autossh"],
        check=False,
        capture_output=True
    )

    if result.returncode == 0:
        print("   âœ“ autossh already installed")
    else:
        print("   Installing autossh via apt...")
        run_command(["apt-get", "update", "-qq"])
        run_command(["apt-get", "install", "-y", "autossh"])
        print("   âœ“ autossh installed")

    # 4. Copy tnl script to /usr/local/bin
    print("\n4. Installing tnl command...")
    current_script = Path(__file__).resolve()
    target_script = Path("/usr/local/bin/tnl")

    if current_script != target_script:
        shutil.copy2(current_script, target_script)
        os.chmod(target_script, 0o755)
        print(f"   âœ“ Copied to {target_script}")
    else:
        print("   âœ“ Already installed")

    # 5. Show public key
    print("\n" + "="*60)
    print("âœ“ Installation complete!")
    print("="*60)
    print("\nğŸ“‹ SSH Public Key (register this on gateway server):\n")

    with open(str(key_path) + ".pub", "r") as f:
        public_key = f.read().strip()
        print(public_key)

    print("\n" + "="*60)
    print("\nNext steps:")
    print("  1. Copy the public key above")
    print("  2. Register this box on gateway server:")
    print("     sudo gtwy add-box <box-id> <domain> '<public-key>'")
    print("\n  3. Get admin port from gateway:")
    print("     gtwy get-port <box-id>")
    print("\n  4. Setup tunnel on this box:")
    print("     sudo tnl setup <gateway-ip> <admin-port>")
    print("     Example: sudo tnl setup 192.168.1.100 20001")
    print("="*60)

def cmd_update(args):
    """Update tnl to new version while preserving configuration."""
    print("ğŸ”„ tnl Update\n")

    check_root()

    # Check if tnl is configured (check for service or SSH key, not just config)
    # v1.0.0 didn't have config.yml, so we check for systemd service instead
    if not Path(SYSTEMD_SERVICE_ADMIN).exists() and not Path(SSH_KEY_PATH).exists():
        print("âŒ tnl not configured. Run 'sudo tnl setup' first.")
        sys.exit(1)

    # Check versions
    installed_version = detect_installed_version()
    current_version = VERSION

    if installed_version == current_version:
        print(f"âœ“ Already running latest version: {current_version}")
        if not args.force:
            return
        print("  --force specified, continuing anyway...")
    else:
        print(f"  Installed: {installed_version}")
        print(f"  New:       {current_version}")

    # 1. Create backup
    print("\n1. Creating backup...")
    backup_dir = f"/etc/tnl/backup-{datetime.now(timezone.utc).strftime('%Y%m%d-%H%M%S')}"
    Path(backup_dir).mkdir(parents=True, exist_ok=True)

    # Backup config
    if Path(TNL_CONFIG_FILE).exists():
        shutil.copy2(TNL_CONFIG_FILE, f"{backup_dir}/config.yml")

    # Backup current executable
    if Path("/usr/local/bin/tnl").exists():
        shutil.copy2("/usr/local/bin/tnl", f"{backup_dir}/tnl.old")

    print(f"   âœ“ Backup created: {backup_dir}")

    # 2. Stop running services
    print("\n2. Stopping services...")
    services = ["tnl-admin.service"]

    # Find all tnl-* services
    result = run_command(
        ["systemctl", "list-units", "tnl-*.service", "--no-legend", "--all"],
        capture_output=True,
        check=False
    )

    if result.returncode == 0:
        for line in result.stdout.splitlines():
            if line.strip():
                service = line.split()[0]
                if service not in services:
                    services.append(service)

    for service in services:
        run_command(["systemctl", "stop", service], check=False)

    print(f"   âœ“ {len(services)} service(s) stopped")

    # 3. Install new executable
    print("\n3. Installing new version...")
    current_script = Path(__file__).resolve()
    shutil.copy2(current_script, "/usr/local/bin/tnl")
    os.chmod("/usr/local/bin/tnl", 0o755)
    print("   âœ“ Executable updated")

    # 4. Migrate config if needed
    print("\n4. Migrating configuration...")

    # For v1.0.0 â†’ v1.2.0: config.yml doesn't exist yet, need to create it
    if not Path(TNL_CONFIG_FILE).exists():
        print("   âš  No config file found (v1.0.0 installation)")
        print("   Creating config from systemd service...")

        # Parse gateway info from systemd service
        try:
            with open(SYSTEMD_SERVICE_ADMIN, 'r') as f:
                service_content = f.read()

            # Extract IP, admin_port, ssh_port from ExecStart line
            # Example: ssh -R 20001:localhost:22 -p 22 tunneluser@87.106.105.160
            import re
            match = re.search(r'-R (\d+):localhost:\d+ -p (\d+) tunneluser@([^\s]+)', service_content)

            if match:
                admin_port = int(match.group(1))
                ssh_port = int(match.group(2))
                gateway_ip = match.group(3)

                config = init_config(gateway_ip, admin_port, ssh_port)
                print(f"   âœ“ Config created: gateway={gateway_ip}, admin_port={admin_port}")
            else:
                print("   âš  Could not parse systemd service, creating minimal config")
                config = {'gateway': {}, 'tunnels': {}, '_meta': {}}
        except Exception as e:
            print(f"   âš  Error parsing service: {e}")
            config = {'gateway': {}, 'tunnels': {}, '_meta': {}}
    else:
        config = load_config()

    migrations_run = run_config_migrations(config, installed_version, current_version)

    if migrations_run or not Path(TNL_CONFIG_FILE).exists():
        save_config(config)
        if migrations_run:
            print(f"   âœ“ {migrations_run} migration(s) applied")
        else:
            print("   âœ“ Configuration created")
    else:
        print("   âœ“ Configuration up to date")

    # 5. Restart services
    print("\n5. Restarting services...")
    for service in services:
        run_command(["systemctl", "start", service], check=False)

    # Wait and check status
    import time
    time.sleep(2)

    active = 0
    for service in services:
        result = run_command(
            ["systemctl", "is-active", service],
            check=False,
            capture_output=True
        )
        if result.stdout.strip() == "active":
            active += 1

    print(f"   âœ“ {active}/{len(services)} service(s) active")

    # 6. Success
    print("\n" + "="*60)
    print(f"âœ“ tnl updated successfully: {installed_version} â†’ {current_version}")
    print("="*60)
    print(f"\nBackup stored at: {backup_dir}")
    print("\nChangelog: https://github.com/steedalot/tnld/releases")

def cmd_setup(args):
    """Setup admin SSH tunnel to gateway server."""
    print("ğŸš€ tnl Tunnel Setup\n")

    check_root()

    if not args.gateway_ip:
        print("âŒ Error: Gateway IP and admin port required")
        print("   Usage: sudo tnl setup <gateway-ip> <admin-port> [ssh-port]")
        sys.exit(1)

    if not args.admin_port:
        print("âŒ Error: Admin port required (from 'gtwy get-port <box-id>')")
        print("   Usage: sudo tnl setup <gateway-ip> <admin-port> [ssh-port]")
        sys.exit(1)

    gateway_ip = args.gateway_ip
    admin_port = args.admin_port
    ssh_port = args.ssh_port if args.ssh_port else 22

    print(f"Gateway IP:    {gateway_ip}")
    print(f"Gateway SSH:   {ssh_port}")
    print(f"Admin Port:    {admin_port} (reverse tunnel)")

    # 1. Test SSH connection
    print("\n1. Testing SSH connection...")
    key_path = Path(SSH_KEY_PATH)

    if not key_path.exists():
        print("âŒ Error: SSH key not found")
        print("   Run 'sudo tnl install' first")
        sys.exit(1)

    result = run_command(
        [
            "sudo", "-u", TUNNELUSER,
            "ssh",
            "-i", str(key_path),
            "-o", "StrictHostKeyChecking=no",
            "-o", "ConnectTimeout=5",
            "-p", str(ssh_port),
            f"tunneluser@{gateway_ip}"
        ],
        check=False,
        capture_output=True
    )

    # Check if connection was successful
    # The command will fail because of command restriction, but that's OK
    # We just need to check if we could connect
    if "usage: gtwy request" in result.stderr or "BOX_ID" in result.stderr:
        # Connection successful! Gateway executed the restricted command
        print("   âœ“ SSH connection successful")
    elif result.returncode != 0:
        print(f"âŒ Error: Cannot connect to gateway")
        print(f"   {result.stderr.strip()}")
        print("\nMake sure:")
        print("  1. Public key is registered on gateway server")
        print("  2. Gateway IP and port are correct")
        print("  3. Firewall allows connection")
        sys.exit(1)
    else:
        print("   âœ“ SSH connection successful")

    # 2. Create config file
    print("\n2. Creating config file...")
    init_config(gateway_ip, admin_port, ssh_port)
    print(f"   âœ“ Config created: {TNL_CONFIG_FILE}")

    # 3. Create systemd service
    print("\n3. Creating systemd service...")

    service_content = f"""[Unit]
Description=tnl Admin SSH Tunnel (Reverse: Gateway:{admin_port} â†’ Box:22)
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
User={TUNNELUSER}
Restart=always
RestartSec=10
ExecStart=/usr/bin/autossh -M 0 -N -o "ServerAliveInterval=30" -o "ServerAliveCountMax=3" -o "ExitOnForwardFailure=yes" -o "StrictHostKeyChecking=no" -i {SSH_KEY_PATH} -R {admin_port}:localhost:22 -p {ssh_port} tunneluser@{gateway_ip}

[Install]
WantedBy=multi-user.target
"""

    with open(SYSTEMD_SERVICE_ADMIN, "w") as f:
        f.write(service_content)

    print(f"   âœ“ Service created: {SYSTEMD_SERVICE_ADMIN}")

    # 4. Reload systemd and enable service
    print("\n4. Enabling service...")
    run_command(["systemctl", "daemon-reload"])
    run_command(["systemctl", "enable", "tnl-admin.service"])
    print("   âœ“ Service enabled")

    # 5. Start service
    print("\n5. Starting service...")
    run_command(["systemctl", "restart", "tnl-admin.service"])
    print("   âœ“ Service started")

    # 6. Check status
    print("\n6. Checking status...")
    import time
    time.sleep(2)

    result = run_command(
        ["systemctl", "is-active", "tnl-admin.service"],
        check=False,
        capture_output=True
    )

    if result.stdout.strip() == "active":
        print("   âœ“ Tunnel is active")
    else:
        print("   âš  Tunnel status:", result.stdout.strip())
        print("\n   Check logs with: journalctl -u tnl-admin.service -f")

    print("\n" + "="*60)
    print("âœ“ Setup complete!")
    print("="*60)
    print(f"\nAdmin SSH tunnel is now running:")
    print(f"  Gateway:{admin_port} â†’ Box:22 (localhost only)")
    print("\nFrom gateway server, connect to this box:")
    print(f"  ssh -p {admin_port} <user>@localhost")
    print("\nUseful commands:")
    print("  sudo systemctl status tnl-admin     # Check status")
    print("  sudo systemctl restart tnl-admin    # Restart tunnel")
    print("  sudo systemctl stop tnl-admin       # Stop tunnel")
    print("  sudo journalctl -u tnl-admin -f     # View logs")
    print("="*60)

def cmd_status(args):
    """Show tunnel status."""
    check_root()

    print("ğŸ“Š tnl Status\n")

    # Check if service exists
    if not Path(SYSTEMD_SERVICE_ADMIN).exists():
        print("âŒ Tunnel not configured")
        print("   Run 'sudo tnl setup <gateway-ip> <admin-port>' first")
        return

    # Service status
    result = run_command(
        ["systemctl", "is-active", "tnl-admin.service"],
        check=False,
        capture_output=True
    )
    status = result.stdout.strip()

    if status == "active":
        print("âœ“ Admin Tunnel: ACTIVE")
    else:
        print(f"âœ— Admin Tunnel: {status.upper()}")

    # Show recent logs
    print("\nRecent logs:")
    print("-" * 60)
    run_command([
        "journalctl", "-u", "tnl-admin.service",
        "-n", "10", "--no-pager"
    ])

def cmd_add(args):
    """Add service tunnel."""
    print("â• Adding Service Tunnel\n")
    check_root()

    service = args.service
    local_port = args.local_port

    # 1. Validate inputs
    print("1. Validating inputs...")
    validate_service_name(service)
    validate_port(local_port)
    print("   âœ“ Inputs valid")

    # 2. Load config
    print("\n2. Loading config...")
    try:
        config = load_config()
    except TnlError as e:
        print(f"âŒ {e}")
        sys.exit(1)

    gateway = config['gateway']
    print(f"   âœ“ Gateway: {gateway['ip']}:{gateway['ssh_port']}")

    # 3. Check if tunnel already exists
    tunnels = config.get('tunnels', {})
    if service in tunnels:
        print(f"âŒ Error: Tunnel for service '{service}' already exists")
        print(f"   Run: sudo tnl list")
        print(f"   Or remove it first: sudo tnl remove {service}")
        sys.exit(1)

    # 4. Request tunnel from gateway
    print(f"\n3. Requesting tunnel from gateway...")
    try:
        result = ssh_request(service, local_port, gateway)

        # Parse JSON response
        data = json.loads(result.stdout.strip())
        server_port = data['server_port']
        subdomain = data['subdomain']

        print(f"   âœ“ Tunnel allocated")
        print(f"   Server Port: {server_port}")
        print(f"   Subdomain:   {subdomain}")
    except json.JSONDecodeError as e:
        print(f"âŒ Error: Failed to parse gateway response")
        print(f"   Response: {result.stdout.strip()}")
        sys.exit(1)
    except TnlError as e:
        print(f"âŒ {e}")
        sys.exit(1)

    # 5. Update config
    print("\n4. Updating config...")
    config.setdefault('tunnels', {})[service] = {
        'local_port': local_port,
        'server_port': server_port,
        'subdomain': subdomain,
        'created': datetime.now(timezone.utc).isoformat(),
        'status': 'active'
    }

    # 6. Create systemd service
    try:
        save_config(config)
        print("   âœ“ Config saved")

        print("\n5. Creating systemd service...")
        create_service_tunnel(service, local_port, server_port, gateway)
        print(f"   âœ“ Service created: tnl-{service}.service")
        print("   âœ“ Service started")

    except Exception as e:
        # ROLLBACK: Remove from config and release on gateway
        print(f"\nâŒ Error during service creation: {e}")
        print("   Rolling back...")

        del config['tunnels'][service]
        save_config(config)
        ssh_release(service, gateway)

        print("   âœ“ Rollback complete")
        sys.exit(1)

    # 7. Success
    print("\n" + "="*60)
    print("âœ“ Tunnel requested successfully!")
    print("="*60)
    print(f"  Service:     {service}")
    print(f"  Local Port:  {local_port}")
    print(f"  Server Port: {server_port}")
    print(f"  URL:         https://{subdomain}")
    print("\n  systemd service: tnl-{service}.service")
    print("="*60)

def cmd_remove(args):
    """Remove service tunnel."""
    print("â– Removing Service Tunnel\n")
    check_root()

    service = args.service

    # 1. Load config
    print("1. Loading config...")
    try:
        config = load_config()
    except TnlError as e:
        print(f"âŒ {e}")
        sys.exit(1)

    gateway = config['gateway']
    tunnels = config.get('tunnels', {})

    # 2. Check if tunnel exists
    if service not in tunnels:
        print(f"âŒ Error: Tunnel '{service}' not found")
        print(f"   Run: sudo tnl list")
        sys.exit(1)

    tunnel = tunnels[service]
    print(f"   âœ“ Found tunnel: {service}")
    print(f"   Subdomain: {tunnel['subdomain']}")

    # 3. Stop systemd service
    print("\n2. Stopping tunnel service...")
    remove_service_tunnel(service)
    print(f"   âœ“ Service stopped and removed")

    # 4. Release on gateway
    print("\n3. Releasing tunnel on gateway...")
    ssh_release(service, gateway)
    print("   âœ“ Tunnel released")

    # 5. Remove from config
    print("\n4. Updating config...")
    del config['tunnels'][service]
    save_config(config)
    print("   âœ“ Config updated")

    # 6. Success
    print("\n" + "="*60)
    print(f"âœ“ Tunnel '{service}' removed")
    print("="*60)

def cmd_list(args):
    """List all service tunnels."""
    check_root()

    print("ğŸ“‹ Service Tunnels\n")

    # Load config
    try:
        config = load_config()
    except TnlError as e:
        print(f"âŒ {e}")
        sys.exit(1)

    tunnels = config.get('tunnels', {})

    if not tunnels:
        print("No service tunnels configured.")
        print("\nAdd a tunnel with: sudo tnl add <service> <port>")
        return

    # Header
    print("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”")
    print("â”‚ Service     â”‚ Local  â”‚ Server  â”‚ URL                                     â”‚ Status   â”‚")
    print("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤")

    active_count = 0
    inactive_count = 0

    for service, tunnel in sorted(tunnels.items()):
        status = get_service_status(service)

        if status == "active":
            active_count += 1
            status_display = "active  "
        else:
            inactive_count += 1
            status_display = "inactive"

        # Truncate/pad fields for alignment
        service_display = service[:11].ljust(11)
        local_port_display = str(tunnel['local_port']).center(6)
        server_port_display = str(tunnel['server_port']).center(7)
        url = f"https://{tunnel['subdomain']}"
        url_display = url[:39].ljust(39)

        print(f"â”‚ {service_display} â”‚ {local_port_display} â”‚ {server_port_display} â”‚ {url_display} â”‚ {status_display} â”‚")

    print("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜")

    total = len(tunnels)
    print(f"\nTotal: {total} tunnel(s) ({active_count} active, {inactive_count} inactive)")

def cmd_version(args):
    """Show version."""
    print(f"tnl v{VERSION}")

# ============================================================================
# ARGUMENT PARSER
# ============================================================================

def build_parser():
    """Build argument parser."""
    parser = argparse.ArgumentParser(
        prog='tnl',
        description='Tunnel Client for IT.Box'
    )

    subparsers = parser.add_subparsers(dest='command', help='Commands')

    # install
    p_install = subparsers.add_parser(
        'install',
        help='Install tnl client (one-time setup)'
    )
    p_install.set_defaults(func=cmd_install)

    # update
    p_update = subparsers.add_parser(
        'update',
        help='Update tnl to new version'
    )
    p_update.add_argument('--force', action='store_true',
                         help='Force update even if same version')
    p_update.set_defaults(func=cmd_update)

    # setup
    p_setup = subparsers.add_parser(
        'setup',
        help='Setup admin SSH tunnel to gateway'
    )
    p_setup.add_argument('gateway_ip', help='Gateway server IP or hostname')
    p_setup.add_argument('admin_port', type=int,
                        help='Admin SSH port (from gtwy get-port)')
    p_setup.add_argument('ssh_port', nargs='?', type=int, default=22,
                        help='Gateway SSH port (default: 22)')
    p_setup.set_defaults(func=cmd_setup)

    # add
    p_add = subparsers.add_parser(
        'add',
        help='Add service tunnel'
    )
    p_add.add_argument('service', help='Service name (e.g., gitea, theia)')
    p_add.add_argument('local_port', type=int, help='Local port (e.g., 3000)')
    p_add.set_defaults(func=cmd_add)

    # remove
    p_remove = subparsers.add_parser(
        'remove',
        help='Remove service tunnel'
    )
    p_remove.add_argument('service', help='Service name')
    p_remove.set_defaults(func=cmd_remove)

    # list
    p_list = subparsers.add_parser(
        'list',
        help='List all service tunnels'
    )
    p_list.set_defaults(func=cmd_list)

    # status
    p_status = subparsers.add_parser(
        'status',
        help='Show admin tunnel status'
    )
    p_status.set_defaults(func=cmd_status)

    # version
    p_version = subparsers.add_parser('version', help='Show version')
    p_version.set_defaults(func=cmd_version)

    return parser

# ============================================================================
# MAIN
# ============================================================================

def main():
    """Main entry point."""
    parser = build_parser()
    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(0)

    try:
        args.func(args)
        sys.exit(0)
    except TnlError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)
    except KeyboardInterrupt:
        print("\nAborted.", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Unexpected error: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == '__main__':
    main()
